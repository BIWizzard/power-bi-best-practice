# 03.4 - Time Intelligence Patterns

## Overview

Time intelligence functions enable year-over-year comparisons, running totals, moving averages, and period-over-period analysisessential for healthcare analytics where trending patient volumes, tracking quality metrics, and comparing clinical performance across time periods drives decision-making. DAX provides powerful time intelligence functions (TOTALYTD, SAMEPERIODLASTYEAR, DATEADD, PARALLELPERIOD), but they require a properly configured date dimension table with contiguous dates marked as a Date Table in the data model. Understanding when to use each time intelligence pattern and how to handle common healthcare fiscal calendar scenarios prevents calculation errors and enables executives to answer "How are we doing compared to last year?" with confidence.

## Key Principles

- **Date Table is Mandatory**: Time intelligence functions require a dedicated date dimension table with contiguous dates (no gaps), marked as Date Table in Power BI, and related to fact tables via date relationships
- **Choose the Right Function**: SAMEPERIODLASTYEAR for YoY comparisons, DATEADD for flexible period shifts, PARALLELPERIOD for month/quarter/year shifts, TOTALYTD for year-to-date running totalseach has specific use cases
- **Fiscal vs. Calendar Year**: Healthcare organizations often use fiscal years (e.g., Oct 1 - Sep 30)time intelligence functions support fiscal year parameters or custom date table calculations
- **Handle Missing Data Gracefully**: Prior period comparisons fail when no data exists (e.g., first year of operation)use ISBLANK checks and conditional logic to prevent errors
- **Variables Improve Performance**: Time intelligence calculations often need prior period values multiple timesstore in variables to avoid redundant calculations (30-40% performance improvement)

## Practical Examples

### Example 1: Year-over-Year (YoY) Growth - Patient Volume

**Scenario:** Calculate YoY patient volume growth showing current year encounters vs. prior year same period with percentage change.

**Prerequisites: Proper date table**

```dax
// Create date table (one-time setup)
// Method 1: CALENDAR function
DimDate =
CALENDAR(
    DATE(2020, 1, 1),  // Start date
    DATE(2030, 12, 31) // End date (future dates for forecasting)
)

// Method 2: CALENDARAUTO (automatic based on fact table dates)
DimDate = CALENDARAUTO()

// Add date attributes
DimDate =
ADDCOLUMNS(
    CALENDAR(DATE(2020, 1, 1), DATE(2030, 12, 31)),
    "Year", YEAR([Date]),
    "Month", FORMAT([Date], "MMM"),
    "MonthNumber", MONTH([Date]),
    "Quarter", "Q" & FORMAT([Date], "Q"),
    "YearMonth", FORMAT([Date], "YYYY-MM"),
    "DayOfWeek", FORMAT([Date], "ddd"),
    "FiscalYear", IF(MONTH([Date]) >= 10, YEAR([Date]) + 1, YEAR([Date])),
    "FiscalQuarter", "FY" & IF(MONTH([Date]) >= 10, YEAR([Date]) + 1, YEAR([Date])) & " Q" & ROUNDUP((MONTH([Date]) - 9) / 3, 0)
)

// Mark as Date Table in Power BI:
// Table Tools ’ Mark as Date Table ’ Select "Date" column
```

**YoY measures:**

```dax
// Current year encounters
Total Encounters =
COUNTROWS(FactEncounter)

// Prior year same period encounters
Total Encounters PY =
CALCULATE(
    [Total Encounters],
    SAMEPERIODLASTYEAR(DimDate[Date])
    // Shifts filter context back exactly 1 year
    // January 2025 ’ January 2024
    // Q1 2025 ’ Q1 2024
)

// YoY absolute change
YoY Encounters Change =
VAR CurrentYearEncounters = [Total Encounters]
VAR PriorYearEncounters = [Total Encounters PY]
VAR AbsoluteChange = CurrentYearEncounters - PriorYearEncounters
RETURN
    AbsoluteChange

// YoY percentage change
YoY Encounters % Change =
VAR CurrentYearEncounters = [Total Encounters]
VAR PriorYearEncounters = [Total Encounters PY]
VAR PercentageChange =
    DIVIDE(
        CurrentYearEncounters - PriorYearEncounters,
        PriorYearEncounters,
        BLANK()  // Return BLANK if no prior year data (avoids #DIV/0)
    )
RETURN
    PercentageChange
```

**Usage in visual:**

```
Matrix: Monthly Encounters with YoY Comparison

Year-Month  | Total Encounters | PY Encounters | YoY Change | YoY % Change
------------|------------------|---------------|------------|-------------
2024-01     | 18,450           | 16,245        | +2,205     | +13.6%
2024-02     | 17,230           | 15,890        | +1,340     | +8.4%
2024-03     | 19,580           | 17,120        | +2,460     | +14.4%
2024-04     | 18,920           | 16,780        | +2,140     | +12.8%
...
2025-01     | 21,340           | 18,450        | +2,890     | +15.7%
2025-02     | 20,150           | 17,230        | +2,920     | +17.0%

How SAMEPERIODLASTYEAR works:
  User viewing 2025-01 (January 2025):
    - Total Encounters: Counts FactEncounter WHERE EncounterDate in Jan 2025 ’ 21,340
    - Total Encounters PY: SAMEPERIODLASTYEAR shifts filter context to Jan 2024
      ’ Counts FactEncounter WHERE EncounterDate in Jan 2024 ’ 18,450
    - YoY Change: 21,340 - 18,450 = +2,890
    - YoY % Change: (21,340 - 18,450) / 18,450 = +15.7%
```

### Example 2: Year-to-Date (YTD) Running Totals

**Scenario:** Calculate year-to-date patient encounters showing cumulative volume from January 1st through current date.

**YTD measures:**

```dax
// Year-to-date encounters (cumulative)
Encounters YTD =
TOTALYTD(
    [Total Encounters],
    DimDate[Date]
    // Automatically filters from Jan 1 to current date in filter context
)

// Example with fiscal year (Oct 1 start)
Encounters FYTD =
TOTALYTD(
    [Total Encounters],
    DimDate[Date],
    "9/30"  // Fiscal year ends September 30
    // YTD calculation runs Oct 1 - current date
)

// Prior year YTD for comparison
Encounters YTD PY =
CALCULATE(
    [Encounters YTD],
    SAMEPERIODLASTYEAR(DimDate[Date])
)

// YTD vs. Prior YTD variance
YTD Variance % =
VAR CurrentYTD = [Encounters YTD]
VAR PriorYTD = [Encounters YTD PY]
VAR Variance = DIVIDE(CurrentYTD - PriorYTD, PriorYTD, BLANK())
RETURN
    Variance
```

**Usage in visual:**

```
Line chart: YTD Encounters Trend

Date       | Encounters YTD | Encounters YTD PY | YTD Variance %
-----------|----------------|-------------------|---------------
2025-01-31 | 21,340         | 18,450            | +15.7%
2025-02-28 | 41,490         | 35,680            | +16.3%
2025-03-31 | 61,070         | 52,800            | +15.7%
2025-04-30 | 79,990         | 69,580            | +15.0%

How TOTALYTD works:
  User viewing 2025-04-30 (April 30, 2025):
    - Encounters YTD: TOTALYTD filters DimDate[Date] from 2025-01-01 to 2025-04-30
      ’ Counts ALL encounters in that range ’ 79,990
    - Encounters YTD PY: Same calculation shifted to 2024-01-01 to 2024-04-30
      ’ 69,580
    - YTD Variance: (79,990 - 69,580) / 69,580 = +15.0%

Visual insight:
  - YTD line shows cumulative growth through year
  - Comparison to PY YTD shows performance trending
  - Variance % indicates if growth accelerating or slowing
```

### Example 3: Moving Averages - Smoothing Volatile Metrics

**Scenario:** 7-day moving average of daily patient census to smooth day-to-day volatility for trend analysis.

**Moving average measures:**

```dax
// Daily patient census (snapshot)
Daily Census =
CALCULATE(
    DISTINCTCOUNT(FactEncounter[PatientKey]),
    FactEncounter[EncounterStatus] = "Active"
)

// 7-day moving average
Census 7-Day MA =
VAR CurrentDate = MAX(DimDate[Date])  // Get current date in filter context
VAR Last7Days =
    DATESINPERIOD(
        DimDate[Date],
        CurrentDate,
        -7,
        DAY  // Include current day + prior 6 days = 7 days total
    )
VAR MovingAverage =
    CALCULATE(
        AVERAGE(DimDate[Daily Census]),  // Average of daily census values
        Last7Days
    )
RETURN
    MovingAverage

// Alternative: 30-day moving average
Census 30-Day MA =
VAR CurrentDate = MAX(DimDate[Date])
VAR Last30Days =
    DATESINPERIOD(
        DimDate[Date],
        CurrentDate,
        -30,
        DAY
    )
VAR MovingAverage =
    CALCULATE(
        AVERAGE(DimDate[Daily Census]),
        Last30Days
    )
RETURN
    MovingAverage
```

**Usage in visual:**

```
Line chart: Daily Census with Moving Averages

Date       | Daily Census | 7-Day MA | 30-Day MA
-----------|--------------|----------|----------
2025-01-15 | 142          | 138      | 145
2025-01-16 | 156          | 141      | 146
2025-01-17 | 128          | 140      | 145
2025-01-18 | 163          | 143      | 146
2025-01-19 | 139          | 144      | 145
2025-01-20 | 147          | 145      | 146
2025-01-21 | 151          | 147      | 147

Insight:
  - Daily Census: Volatile (swings 128-163)
  - 7-Day MA: Smoothed short-term trend (138-147)
  - 30-Day MA: Stable long-term trend (145-147)
  - Decision: MA shows steady increase despite daily volatility
```

**Healthcare use case: Staffing decisions**

```
Daily census highly variable (weekends low, Mondays high, discharges spike Fridays)
  ’ 7-day MA reveals true census trend
  ’ Staffing models use 7-day MA to forecast next week's needs
  ’ Avoids over-staffing based on single high day or under-staffing based on weekend dip
```

### Example 4: Month-over-Month (MoM) and Quarter-over-Quarter (QoQ) Comparisons

**Scenario:** Track patient satisfaction scores trending month-over-month and quarter-over-quarter.

**MoM and QoQ measures:**

```dax
// Current period average satisfaction score
Avg Satisfaction Score =
AVERAGE(FactSurvey[SatisfactionScore])

// Prior month score (MoM comparison)
Avg Satisfaction Score PM =
CALCULATE(
    [Avg Satisfaction Score],
    DATEADD(DimDate[Date], -1, MONTH)
    // Shifts filter context back 1 month
    // March 2025 ’ February 2025
)

// Alternative: PARALLELPERIOD (similar to DATEADD for month/quarter/year)
Avg Satisfaction Score PM (Alt) =
CALCULATE(
    [Avg Satisfaction Score],
    PARALLELPERIOD(DimDate[Date], -1, MONTH)
)

// Prior quarter score (QoQ comparison)
Avg Satisfaction Score PQ =
CALCULATE(
    [Avg Satisfaction Score],
    DATEADD(DimDate[Date], -1, QUARTER)
    // Q1 2025 ’ Q4 2024
)

// MoM change
MoM Satisfaction Change =
VAR CurrentScore = [Avg Satisfaction Score]
VAR PriorMonthScore = [Avg Satisfaction Score PM]
VAR Change = CurrentScore - PriorMonthScore
RETURN
    Change

// MoM percentage change
MoM Satisfaction % Change =
VAR CurrentScore = [Avg Satisfaction Score]
VAR PriorMonthScore = [Avg Satisfaction Score PM]
VAR PercentChange = DIVIDE(CurrentScore - PriorMonthScore, PriorMonthScore, BLANK())
RETURN
    PercentChange
```

**DATEADD vs. PARALLELPERIOD differences:**

```
DATEADD:
  - More flexible: Can shift by day, month, quarter, year
  - Example: DATEADD(DimDate[Date], -7, DAY) ’ 7 days back
  - Example: DATEADD(DimDate[Date], -2, MONTH) ’ 2 months back

PARALLELPERIOD:
  - Limited to month, quarter, year shifts
  - Slightly different behavior at period boundaries
  - Generally prefer DATEADD for flexibility

Recommendation: Use DATEADD for consistency across all time shifts
```

## Common Pitfalls

### Pitfall 1: Missing or Improperly Configured Date Table

Using time intelligence functions without a proper date dimension table marked as Date Table, causing functions to fail or return incorrect results.

**Impact**: Time intelligence functions return BLANK or error, SAMEPERIODLASTYEAR doesn't work (no results), TOTALYTD returns wrong values, confusing error messages ("Cannot find table 'Date'"), measures work in some contexts but not others (unpredictable).

**Example mistake:**

```dax
// No date table in model, only FactEncounter[EncounterDate]

// L FAILS: Time intelligence requires date table
Encounters YTD =
TOTALYTD(
    [Total Encounters],
    FactEncounter[EncounterDate]  //  Not a date table!
)

Error or unexpected result:
  - Function returns BLANK
  - Or counts all encounters (ignores YTD filter)
  - No clear error message explaining why
```

**Fix: Create and configure date table**

```dax
// Step 1: Create date table
DimDate =
ADDCOLUMNS(
    CALENDAR(DATE(2020, 1, 1), DATE(2030, 12, 31)),
    "Year", YEAR([Date]),
    "MonthNumber", MONTH([Date]),
    "MonthName", FORMAT([Date], "MMMM"),
    "Quarter", "Q" & FORMAT([Date], "Q"),
    "YearQuarter", YEAR([Date]) & " Q" & FORMAT([Date], "Q")
)

// Step 2: Mark as Date Table
// Power BI Desktop:
//   1. Select DimDate table
//   2. Table Tools ’ Mark as Date Table
//   3. Select "Date" column as the date column
//   4. Power BI validates: contiguous dates, no duplicates, no gaps

// Step 3: Create relationship
// Relationship: DimDate[Date] ’ FactEncounter[EncounterDate]
// Cardinality: One-to-Many (1:*)
// Cross-filter direction: Single (DimDate filters FactEncounter)

// Step 4: Time intelligence now works
Encounters YTD =
TOTALYTD(
    [Total Encounters],
    DimDate[Date]  //  Date table marked as Date Table
)

Result:  Works correctly, YTD calculation accurate
```

**Date table validation checklist:**

```
 Contiguous dates (no gaps): Every date from start to end present
 Unique dates (no duplicates): Each date appears exactly once
 Covers data range: Date table spans earliest to latest fact table dates (+ future for forecasting)
 Marked as Date Table: Table Tools ’ Mark as Date Table
 Related to facts: Relationship from DimDate[Date] to FactTable[DateColumn]
 Date data type: Column is Date type (not DateTime or Text)

Common mistakes:
 Gaps in dates (e.g., only weekdays, missing weekends)
 Duplicate dates (multiple rows for same date)
 DateTime column instead of Date (time component causes issues)
 Not marked as Date Table (time intelligence fails)
 No relationship to fact tables (filter context doesn't propagate)
```

### Pitfall 2: Using Time Intelligence Functions with Non-Date Columns

Applying time intelligence functions to non-contiguous date columns or columns not in a proper date table (e.g., FactEncounter[EncounterDate] directly).

**Impact**: Functions return BLANK or incorrect values, unpredictable behavior (works sometimes, fails other times), difficult to debug (no clear error message), calculations appear to work but are wrong (silently incorrect).

**Example mistake:**

```dax
// L WRONG: Using fact table date column directly
Encounters Last Year =
CALCULATE(
    [Total Encounters],
    SAMEPERIODLASTYEAR(FactEncounter[EncounterDate])  //  Not a date table!
)

Problems:
1. FactEncounter[EncounterDate] has gaps (no encounters on some dates)
2. Not marked as Date Table
3. Time intelligence requires contiguous date range
4. Function returns BLANK or unpredictable results

Example gap issue:
  FactEncounter dates: 2024-01-05, 2024-01-07, 2024-01-09 (missing 1/6, 1/8)
  SAMEPERIODLASTYEAR can't shift properly with gaps
  Result: Incorrect prior year values
```

**Fix: Always use date table**

```dax
//  CORRECT: Use DimDate date table
Encounters Last Year =
CALCULATE(
    [Total Encounters],
    SAMEPERIODLASTYEAR(DimDate[Date])  //  Proper date table
)

Why this works:
  - DimDate has ALL dates (1/1 through 12/31, no gaps)
  - Marked as Date Table (validates contiguity)
  - SAMEPERIODLASTYEAR can reliably shift 365 days
  - Relationship filters FactEncounter to matching dates
  - Result: Correct prior year calculations
```

### Pitfall 3: Not Handling BLANK Values in Time Comparisons

Creating measures that divide by prior period values without checking for BLANK (no data in prior period), causing #DIV/0 errors or misleading results.

**Impact**: Visual shows errors instead of useful data, blank rows where prior period has no data (confusing users), percentage calculations fail, measures marked with error icon, users lose confidence in report accuracy.

**Example mistake:**

```dax
// L BAD: No BLANK handling
YoY Growth % =
DIVIDE(
    [Total Encounters] - [Total Encounters PY],
    [Total Encounters PY]
    // If PY is BLANK (no prior year data), DIVIDE returns ERROR
)

Problem scenarios:
  - First year of operation (2020): No 2019 data to compare
    ’ [Total Encounters PY] = BLANK
    ’ Calculation fails or shows misleading 100% growth

  - New facility opened mid-year: Prior year has no data
    ’ BLANK denominator
    ’ Error in visual
```

**Fix: Conditional logic and ISBLANK checks**

```dax
//  GOOD: Handle BLANK explicitly
YoY Growth % =
VAR CurrentYear = [Total Encounters]
VAR PriorYear = [Total Encounters PY]
VAR HasPriorYearData = NOT(ISBLANK(PriorYear))
VAR GrowthPercent =
    IF(
        HasPriorYearData,
        DIVIDE(CurrentYear - PriorYear, PriorYear, 0),
        BLANK()  // Return BLANK if no prior year data (don't show misleading %)
    )
RETURN
    GrowthPercent

Result:
  - 2020 (first year): YoY Growth % = BLANK (no prior year to compare)
  - 2021 onwards: YoY Growth % = calculated percentage
  - Visuals: BLANK cells instead of errors
  - Users understand: "No prior year data available"
```

**Alternative: Show helpful message**

```dax
YoY Growth % (Text) =
VAR CurrentYear = [Total Encounters]
VAR PriorYear = [Total Encounters PY]
VAR HasPriorYearData = NOT(ISBLANK(PriorYear))
VAR GrowthPercent =
    IF(
        HasPriorYearData,
        DIVIDE(CurrentYear - PriorYear, PriorYear, 0),
        BLANK()
    )
RETURN
    IF(
        ISBLANK(GrowthPercent),
        "N/A - No Prior Year",  // User-friendly message
        FORMAT(GrowthPercent, "0.0%")
    )

Visual shows:
  2020: "N/A - No Prior Year"
  2021: "+12.5%"
  2022: "+8.3%"
```

## Healthcare Context

### Clinical Quality Metrics Trending

Healthcare quality measures (HEDIS, CMS Stars) require year-over-year trending to demonstrate improvement.

**Example: Diabetic HbA1c Control Rate - 3 Year Trend**

```dax
HbA1c Control Rate =
// Patients with HbA1c <8% / Total diabetic patients
VAR ControlledPatients =
    CALCULATE(
        DISTINCTCOUNT(FactLabResult[PatientKey]),
        FactLabResult[LabTest] = "HbA1c",
        FactLabResult[MostRecentValue] < 8.0
    )
VAR TotalDiabeticPatients =
    CALCULATE(
        DISTINCTCOUNT(DimPatient[PatientKey]),
        DimDiagnosis[DiagnosisCategory] = "Diabetes"
    )
VAR ControlRate = DIVIDE(ControlledPatients, TotalDiabeticPatients, 0)
RETURN
    ControlRate

// Year-over-year comparison
HbA1c Control Rate PY =
CALCULATE(
    [HbA1c Control Rate],
    SAMEPERIODLASTYEAR(DimDate[Date])
)

// 3-year trend for CMS reporting
HbA1c Control Rate 2Y Ago =
CALCULATE(
    [HbA1c Control Rate],
    DATEADD(DimDate[Date], -2, YEAR)
)

Visual:
  Measurement Year | Control Rate | YoY Change
  -----------------|--------------|------------
  2023             | 68.2%        | --
  2024             | 72.5%        | +4.3 pts    Improvement
  2025             | 74.1%        | +1.6 pts    Continued improvement

Compliance note: CMS Stars requires 3-year trend showing improvement
```

### Fiscal Year Reporting

Many healthcare organizations use Oct 1 - Sep 30 fiscal year (aligns with federal fiscal year).

**Example: Fiscal YTD Revenue**

```dax
// Fiscal year definition (Oct 1 start)
Revenue FYTD =
TOTALYTD(
    SUM(FactEncounter[EncounterRevenue]),
    DimDate[Date],
    "9/30"  // Fiscal year end = September 30
)

// Alternative: Add FiscalYear column to DimDate
// DimDate[FiscalYear] =
// IF(MONTH(DimDate[Date]) >= 10, YEAR(DimDate[Date]) + 1, YEAR(DimDate[Date]))

// Use FiscalYear for filtering
Revenue FYTD (Alt) =
VAR SelectedFiscalYear = SELECTEDVALUE(DimDate[FiscalYear])
VAR FiscalYearStart = DATE(SelectedFiscalYear - 1, 10, 1)  // Oct 1 of prior calendar year
VAR FiscalYearEnd = DATE(SelectedFiscalYear, 9, 30)  // Sep 30 of current calendar year
VAR CurrentDate = MAX(DimDate[Date])
VAR FYTDRevenue =
    CALCULATE(
        SUM(FactEncounter[EncounterRevenue]),
        DimDate[Date] >= FiscalYearStart &&
        DimDate[Date] <= MIN(CurrentDate, FiscalYearEnd)
    )
RETURN
    FYTDRevenue

Usage:
  Report filtered to FY2025 (Oct 1, 2024 - Sep 30, 2025)
  User viewing April 2025:
    - Revenue FYTD: Oct 2024 through Apr 2025 cumulative revenue
```

### Patient Readmission Tracking - 30-Day Windows

30-day readmission rates use DATESINPERIOD to define rolling 30-day windows.

**Example: 30-Day Readmission Flag**

```dax
// Calculated column in FactEncounter
Is 30-Day Readmission =
VAR CurrentEncounterDate = FactEncounter[EncounterDate]
VAR PatientKey = FactEncounter[PatientKey]
VAR PriorDischargeDate =
    CALCULATE(
        MAX(FactEncounter[DischargeDate]),
        FactEncounter[PatientKey] = PatientKey,
        FactEncounter[DischargeDate] < CurrentEncounterDate,
        FactEncounter[DischargeDate] >= CurrentEncounterDate - 30
        // Look for discharge in prior 30 days
    )
VAR DaysSinceLastDischarge =
    IF(
        NOT(ISBLANK(PriorDischargeDate)),
        CurrentEncounterDate - PriorDischargeDate,
        BLANK()
    )
VAR IsReadmission = DaysSinceLastDischarge <= 30
RETURN
    IsReadmission

// Measure: 30-day readmission rate
30-Day Readmission Rate =
VAR Readmissions =
    CALCULATE(
        COUNTROWS(FactEncounter),
        FactEncounter[Is 30-Day Readmission] = TRUE()
    )
VAR TotalDischarges = COUNTROWS(FactEncounter)
VAR ReadmissionRate = DIVIDE(Readmissions, TotalDischarges, 0)
RETURN
    ReadmissionRate
```

### Assessment Integration: Date Table Creation

**AbsoluteCare assessment identified date table as missing**time intelligence patterns require dedicated date dimension.

**Implementation recommendation:**

```sql
-- Create DimDate in ABCDW database (recommended)
CREATE VIEW ABCDW.StarSchema.DimDate AS
WITH DateRange AS (
    SELECT CAST('2020-01-01' AS DATE) AS DateValue
    UNION ALL
    SELECT DATEADD(DAY, 1, DateValue)
    FROM DateRange
    WHERE DateValue < '2030-12-31'
)
SELECT
    DateValue AS [Date],
    YEAR(DateValue) AS [Year],
    MONTH(DateValue) AS MonthNumber,
    DATENAME(MONTH, DateValue) AS MonthName,
    DATEPART(QUARTER, DateValue) AS QuarterNumber,
    'Q' + CAST(DATEPART(QUARTER, DateValue) AS VARCHAR) AS Quarter,
    DATENAME(WEEKDAY, DateValue) AS DayOfWeekName,
    DATEPART(WEEKDAY, DateValue) AS DayOfWeekNumber,
    -- Fiscal year (Oct 1 start for federal alignment)
    CASE
        WHEN MONTH(DateValue) >= 10 THEN YEAR(DateValue) + 1
        ELSE YEAR(DateValue)
    END AS FiscalYear
FROM DateRange
OPTION (MAXRECURSION 0);

-- Import into Power BI, mark as Date Table, relate to FactEncounter[EncounterDate]
```

## Learn More

### Official Documentation

- [Time Intelligence Functions](https://learn.microsoft.com/en-us/dax/time-intelligence-functions-dax) - Microsoft's complete time intelligence function reference
- [Create Date Tables](https://learn.microsoft.com/en-us/power-bi/guidance/model-date-tables) - Microsoft's guide to date table design
- [TOTALYTD Function](https://learn.microsoft.com/en-us/dax/totalytd-function-dax) - Official TOTALYTD documentation with fiscal year examples

### Expert Resources

- [SQLBI - Time Intelligence in DAX](https://www.sqlbi.com/articles/time-intelligence-in-dax/) - Marco Russo's comprehensive guide to all time intelligence patterns
- [SQLBI - The Date Table](https://www.sqlbi.com/articles/create-a-date-table-in-power-bi/) - Best practices for date table creation
- [The Definitive Guide to DAX - Chapter 6](https://www.sqlbi.com/books/the-definitive-guide-to-dax-2nd-edition/) - Time intelligence patterns in depth
- [DAX Patterns - Time Intelligence](https://www.daxpatterns.com/time-patterns/) - Common time intelligence calculation patterns

### Video Content

- [SQLBI - Time Intelligence Demystified](https://www.sqlbi.com/tv/time-intelligence-in-dax/) - Visual explanation of time intelligence concepts
- [Guy in a Cube - Date Tables and Time Intelligence](https://www.youtube.com/c/GuyinaCube) - Patrick and Adam demonstrate date table setup

### Related Topics

- [03.3 - Filter Context & Context Transition](./03.3%20-%20Filter%20Context%20&%20Context%20Transition.md) - Time intelligence modifies filter context
- [03.2 - Variables & Code Readability](./03.2%20-%20Variables%20&%20Code%20Readability.md) - Variables improve time intelligence measure performance
- [01.1 - Star Schema Design Principles](../01%20-%20Data%20Architecture%20&%20Semantic%20Modeling/01.1%20-%20Star%20Schema%20Design%20Principles.md) - Date dimension as foundational dimension table
- [03.5 - Common DAX Anti-patterns](./03.5%20-%20Common%20DAX%20Anti-patterns.md) - Time intelligence mistakes to avoid

---

*Last updated: October 21, 2025*
