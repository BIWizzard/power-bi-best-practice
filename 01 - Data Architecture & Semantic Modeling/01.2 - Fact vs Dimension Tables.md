# 01.2 - Fact vs Dimension Tables

## Overview

Fact and dimension tables are the foundational building blocks of star schema data modeling in Power BI. Fact tables contain measurable business events (encounters, charges, admissions) with numeric values to aggregate. Dimension tables contain descriptive attributes used to slice, filter, and group fact data (patients, providers, dates, locations). Understanding the distinction and properly separating facts from dimensions is critical for building scalable, performant, and maintainable Power BI semantic models - especially when moving away from "One Big Table" denormalized approaches common in early-stage BI implementations.

## Key Principles

- **Facts Are About Events, Dimensions Are About Context**: Fact tables answer "what happened" (patient encounter, charge transaction, medication order). Dimension tables answer "who, what, when, where" (which patient, which provider, which facility, which date).

- **Facts Grow Continuously, Dimensions Grow Slowly**: Fact tables add rows constantly as business events occur (new encounters daily). Dimension tables change infrequently (new providers hired monthly, facility list stable). This growth pattern drives different optimization strategies.

- **Facts Are Many-to-One with Dimensions**: Each fact row links to ONE dimension row via foreign key (many encounters link to one patient, many charges link to one provider). This relationship enables efficient filtering and grouping without data duplication.

- **Denormalized "One Big Table" Trades Performance for Short-Term Simplicity**: Combining facts and dimensions into one wide table appears simple initially but creates maintenance problems, performance issues, and data quality challenges as models scale. Normalizing to star schema is the sustainable path forward.

- **Identify Source of Truth for Each Dimension**: Before creating dimension tables, establish where authoritative data resides (Member master table, Provider credentialing system, Epic Caboodle dimensions). Use these as source of truth to avoid conflicting data versions.

## Practical Example

### Example 1: Moving from "One Big Table" to Star Schema

**L Current State at AbsoluteCare: Denormalized "One Big Table"**

```powerquery
// Single table with all encounter data (simplified example)
let
    Source = Sql.Database("ABCDW", "Healthcare"),
    vwEncounterDetails = Source{[Schema="dbo",Item="vwEncounterDetails"]}[Data]
    // Contains 100+ columns mixing fact and dimension data:
    // EncounterID, EncounterDate, ChargeAmount, PatientMRN, PatientFirstName,
    // PatientLastName, PatientDOB, PatientAddress, ProviderNPI, ProviderName,
    // ProviderSpecialty, FacilityName, FacilityAddress, PayerName, PayerID, etc.
in
    vwEncounterDetails
```

**Problems with this approach**:
- **Data duplication**: Patient name stored in every encounter row (same patient has 20 encounters = name stored 20 times)
- **Update complexity**: Patient address change requires updating millions of encounter rows
- **Poor compression**: VertiPaq compression less effective with repeated text values
- **Relationship issues**: Can't create relationships between entities (patient to payer without encounters)
- **Maintenance burden**: 100+ column tables hard to understand and modify
- **Performance degradation**: Large models (>2 GB) with redundant data

** Target State: Normalized Star Schema**

```powerquery
// FACT TABLE: FactEncounters (events/transactions)
let
    Source = Sql.Database("ABCDW", "Healthcare"),
    FactEncounters = Source{[Schema="dbo",Item="FactEncounters"]}[Data],
    SelectColumns = Table.SelectColumns(FactEncounters, {
        "EncounterKey",         // Surrogate key
        "EncounterDate",        // Date for relationship to DimDate
        "PatientKey",           // FK to DimPatient
        "ProviderKey",          // FK to DimProvider
        "FacilityKey",          // FK to DimFacility
        "PayerKey",             // FK to DimPayer
        "ChargeAmount",         // Measurable value
        "EncounterCount",       // Measurable value (often = 1)
        "LengthOfStay"          // Measurable value
    })
in
    SelectColumns

// DIMENSION TABLE: DimPatient (descriptive attributes)
let
    Source = Sql.Database("ABCDW", "Healthcare"),
    DimPatient = Source{[Schema="dbo",Item="DimPatient"]}[Data],
    SelectColumns = Table.SelectColumns(DimPatient, {
        "PatientKey",           // Surrogate primary key
        "MRN",                  // Business key
        "FirstName",            // Attribute
        "LastName",             // Attribute
        "DateOfBirth",          // Attribute
        "Gender",               // Attribute
        "City",                 // Attribute
        "State",                // Attribute
        "PrimaryPayerKey"       // FK to DimPayer (current payer)
    })
in
    SelectColumns

// DIMENSION TABLE: DimProvider (descriptive attributes)
let
    Source = Sql.Database("ABCDW", "Healthcare"),
    DimProvider = Source{[Schema="dbo",Item="DimProvider"]}[Data],
    SelectColumns = Table.SelectColumns(DimProvider, {
        "ProviderKey",          // Surrogate primary key
        "NPI",                  // Business key
        "ProviderName",         // Attribute
        "Specialty",            // Attribute
        "PracticeName",         // Attribute
        "IsActive"              // Attribute
    })
in
    SelectColumns

// DIMENSION TABLE: DimFacility
// DIMENSION TABLE: DimPayer
// DIMENSION TABLE: DimDate (see Topic 03.4 - Time Intelligence)
```

**Data Model Relationships**:
```
DimDate (1) -----> (*) FactEncounters
DimPatient (1) ---> (*) FactEncounters
DimProvider (1) ---> (*) FactEncounters
DimFacility (1) ---> (*) FactEncounters
DimPayer (1) -----> (*) FactEncounters
```

**Why this works**:
- **Eliminate duplication**: Patient name stored once in DimPatient, referenced by key
- **Easy updates**: Patient address change updates one row in DimPatient
- **Better compression**: VertiPaq compresses integer keys more efficiently than repeated text
- **Flexible analysis**: Can analyze patients independent of encounters, or encounters independent of patients
- **Smaller model**: Assessment data shows 40-60% model size reduction after normalization
- **Faster refresh**: Less data to transfer and compress
- **DAX simplification**: RELATED() function enables easy dimension attribute access from fact context

### Example 2: Identifying Foundational Dimensions

**Assessment Recommendation**: Identify and create key healthcare dimensions as building blocks.

**Foundational Healthcare Dimensions**:

1. **DimPatient (Members)**
   - Source of Truth: Member master table, Epic Patient table, enrollment system
   - Key Attributes: MRN, Name, DOB, Address, Current Payer, Risk Score, Care Pathway
   - Growth: Slow (new patients monthly)

2. **DimProvider**
   - Source of Truth: Credentialing system, Epic Provider table, HR system
   - Key Attributes: NPI, Name, Specialty, Practice, Employment Status
   - Growth: Very slow (new providers quarterly)

3. **DimFacility (Locations)**
   - Source of Truth: Facility master table, Service Area definitions
   - Key Attributes: Facility ID, Name, Address, Type (Hospital/Clinic/SNF), Service Area
   - Growth: Very slow (new locations yearly)

4. **DimPayer**
   - Source of Truth: Payer contract system, claims system payer table
   - Key Attributes: Payer ID, Payer Name, Payer Type (Medicare/Medicaid/Commercial), Contract Terms
   - Growth: Slow (new payer contracts annually)

5. **DimDate**
   - Source of Truth: Generated in Power BI or SQL Server
   - Key Attributes: Date, Year, Quarter, Month, Week, Day, Fiscal Year, Is Holiday
   - Growth: None (pre-generated for date range)

6. **DimService/Procedure**
   - Source of Truth: CPT/ICD code master, service catalog
   - Key Attributes: Service Code, Description, Category, Revenue Category
   - Growth: Slow (code updates annually)

**Implementation Strategy** (Assessment Recommendation):

```sql
-- Create a schema in source SQL database for star schema views
CREATE SCHEMA [StarSchema];

-- Create DimPatient view as source of truth
CREATE VIEW [StarSchema].[DimPatient] AS
SELECT
    ROW_NUMBER() OVER (ORDER BY MRN) AS PatientKey,  -- Surrogate key
    MRN,                                             -- Business key
    FirstName,
    LastName,
    DateOfBirth,
    Gender,
    City,
    State,
    CASE WHEN EnrollmentEndDate IS NULL OR EnrollmentEndDate > GETDATE()
         THEN 1 ELSE 0 END AS IsActive
FROM SourceSystem.MemberMaster
WHERE MRN IS NOT NULL;

-- Create DimProvider view
CREATE VIEW [StarSchema].[DimProvider] AS
SELECT
    ROW_NUMBER() OVER (ORDER BY NPI) AS ProviderKey,  -- Surrogate key
    NPI,                                              -- Business key
    ProviderName,
    Specialty,
    PracticeName,
    CASE WHEN TerminationDate IS NULL THEN 1 ELSE 0 END AS IsActive
FROM SourceSystem.ProviderCredentialing
WHERE NPI IS NOT NULL;

-- Reference these views in Power BI Power Query
```

**Benefits**:
- Dimensions available for ALL future reports (consistent definitions)
- SQL views can be refined iteratively without breaking reports
- Prepares for future data warehouse/medallion architecture migration
- Establishes "source of truth" for each entity
- Views serve as scoping artifacts for architecture planning

### Example 3: Role-Playing Dimensions

**Scenario**: FactEncounters references DimProvider multiple times (Attending Provider, Referring Provider, Billing Provider).

**L Wrong Approach: Create Separate Provider Tables**

```powerquery
DimAttendingProvider = DimProvider  // Duplicate table
DimReferringProvider = DimProvider  // Duplicate table
DimBillingProvider = DimProvider    // Duplicate table
```

**Problems**:
- 3x memory usage (same provider data stored 3 times)
- Maintenance nightmare (update provider name in 3 places)
- Slicers need 3 separate provider slicers (confusing UX)

** Correct Approach: Single Dimension with Multiple Relationships**

```powerquery
// One DimProvider table
DimProvider (with ProviderKey, NPI, ProviderName, Specialty, etc.)

// FactEncounters with multiple provider keys
FactEncounters (
    EncounterKey,
    AttendingProviderKey,    // FK to DimProvider
    ReferringProviderKey,    // FK to DimProvider
    BillingProviderKey,      // FK to DimProvider
    ...
)
```

**In Power BI Model**:
1. Create relationship: DimProvider[ProviderKey] ’ FactEncounters[AttendingProviderKey] (Active)
2. Create relationship: DimProvider[ProviderKey] ’ FactEncounters[ReferringProviderKey] (Inactive)
3. Create relationship: DimProvider[ProviderKey] ’ FactEncounters[BillingProviderKey] (Inactive)

**DAX measures using inactive relationships**:

```dax
// Use active relationship (Attending Provider)
Total Encounters = COUNTROWS(FactEncounters)

// Use inactive relationship explicitly
Encounters by Referring Provider =
CALCULATE(
    COUNTROWS(FactEncounters),
    USERELATIONSHIP(DimProvider[ProviderKey], FactEncounters[ReferringProviderKey])
)

Encounters by Billing Provider =
CALCULATE(
    COUNTROWS(FactEncounters),
    USERELATIONSHIP(DimProvider[ProviderKey], FactEncounters[BillingProviderKey])
)
```

**Why this works**: One provider dimension, multiple ways to filter encounters. Memory efficient, maintainable, and flexible.

## Common Pitfalls

### L Pitfall 1: Putting Slowly-Changing Attributes in Fact Tables

**Description**: Storing provider specialty, patient address, or payer name directly in fact table because "the data might change."

**Impact**:
- Data duplication (patient address stored millions of times in encounter rows)
- Update complexity (patient moves, must update all historical encounters?)
- Historical accuracy questions (should old encounters reflect old or new address?)
- Poor compression and performance

**Fix**: Use Type 2 Slowly Changing Dimensions (SCD2) if historical accuracy matters:

```sql
-- DimPatient with SCD Type 2
CREATE TABLE StarSchema.DimPatient (
    PatientKey INT PRIMARY KEY,      -- Surrogate key
    MRN VARCHAR(20),                 -- Business key (same for all versions)
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Address VARCHAR(200),
    EffectiveDate DATE,              -- When this version became effective
    EndDate DATE,                    -- When this version expired (NULL = current)
    IsCurrent BIT                    -- 1 for current version, 0 for historical
);
```

With SCD2, encounters link to the patient dimension version that was current when the encounter occurred.

For most healthcare analytics, Type 1 (overwrite) is sufficient - showing current patient address for all encounters is acceptable.

### L Pitfall 2: Creating Facts Without Numeric Measures

**Description**: Creating "fact" tables that only contain foreign keys and no numeric values to aggregate.

**Impact**: Not actually a fact table - it's a bridge table or junction table. Causes confusion and potential performance issues if large.

**Example**:
```sql
-- This is NOT a fact table (no measures to aggregate)
CREATE TABLE PatientProviderAssignment (
    PatientKey INT,
    ProviderKey INT,
    AssignmentDate DATE
);
```

**Fix**:
- If it's a many-to-many relationship, create it as a bridge table and document it as such
- Consider adding a measure (e.g., AssignmentCount = 1) to make it a proper fact
- Or denormalize into dimension if cardinality is low (patient has primary provider attribute in DimPatient)

### L Pitfall 3: Using Natural Keys for Relationships

**Description**: Using business keys (MRN, NPI) instead of surrogate keys (PatientKey, ProviderKey) for relationships between fact and dimension tables.

**Impact**:
- Text-based relationships perform poorly (integer key joins 10x faster)
- MRNs/NPIs can change or have data quality issues (nulls, duplicates)
- Composite keys (multi-column) don't work in Power BI relationships
- Harder to handle SCD Type 2 (business key same for all versions)

**Fix**: Always use integer surrogate keys for relationships:

```sql
-- WRONG: Natural key relationship
FactEncounters.PatientMRN ’ DimPatient.MRN (varchar relationship)

-- CORRECT: Surrogate key relationship
FactEncounters.PatientKey ’ DimPatient.PatientKey (integer relationship)
```

Store natural keys (MRN, NPI) as attributes in dimension for display and filtering, but use surrogate keys for relationships.

## Healthcare Context

### Performance Considerations

Fact vs dimension separation directly impacts <5 second load time SLA:

**Model Size Reduction**: Assessment data shows normalizing from "One Big Table" to star schema reduces model size 40-60%, improving:
- Refresh time (less data to load)
- Query performance (better VertiPaq compression)
- Memory usage (lower Premium capacity requirements)

**Query Performance**: Relationships between facts and dimensions leverage VertiPaq's columnar storage and compression. Integer foreign key joins are highly optimized.

**Scalability**: Star schema supports multi-million row fact tables with fast query performance. Denormalized tables struggle beyond 1-2 million rows.

### Print/Mobile Implications

**Smaller Models = Better Mobile Performance**: Normalized models compress better, resulting in smaller dataset downloads to Power BI mobile apps. This improves offline mobile scenarios (providers in rural areas).

**Reusable Dimensions**: Dimensions like DimPatient, DimProvider work across all reports. Build once, use everywhere = consistent mobile experience.

### Compliance Notes

**Data Lineage**: Separating facts from dimensions clarifies data lineage - where each data element comes from (source of truth). This supports HIPAA audit requirements and data governance documentation.

**Row-Level Security**: RLS typically implemented on dimension tables (user sees subset of patients, providers). Star schema makes RLS implementation cleaner than filtering denormalized tables. See [06.1 - Row-Level Security Patterns](../06%20-%20Governance%20Security%20&%20Deployment/06.1%20-%20Row-Level%20Security%20Patterns.md).

## Learn More

### Official Documentation
- [Star Schema Design in Power BI](https://learn.microsoft.com/en-us/power-bi/guidance/star-schema) - Microsoft guidance on star schema best practices
- [Table Relationships in Power BI](https://learn.microsoft.com/en-us/power-bi/transform-model/desktop-create-and-manage-relationships) - Creating and managing fact-dimension relationships

### Expert Resources
- [Analyzing Data with Power BI and Power Pivot for Excel](https://www.sqlbi.com/books/analyzing-data-with-power-bi-and-power-pivot-for-excel/) - Marco Russo & Alberto Ferrari book, chapters 5-7 on data modeling
- [Star Schema vs Snowflake Schema](https://www.sqlbi.com/articles/star-schema-or-snowflake-schema/) - SQLBI article explaining schema design choices
- [Fact Tables Design Patterns](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/) - Kimball Group dimensional modeling techniques

### Video Content
- [Fact Tables vs Dimension Tables](https://www.youtube.com/c/GuyinaCube) - Guy in a Cube explanation with Power BI examples
- [Building Star Schemas in Power BI](https://www.youtube.com/c/SQLBI) - SQLBI video on star schema implementation

### Related Topics
- [01.1 - Star Schema Design Principles](01.1%20-%20Star%20Schema%20Design%20Principles.md) - Overall star schema design guidance
- [01.3 - Relationship Configuration & Cardinality](01.3%20-%20Relationship%20Configuration%20&%20Cardinality.md) - Configuring fact-dimension relationships
- [01.4 - Calculated Columns vs Measures](01.4%20-%20Calculated%20Columns%20vs%20Measures.md) - Where to place calculations
- [01.5 - Bridging to Medallion Architecture](01.5%20-%20Bridging%20to%20Medallion%20Architecture.md) - Preparing for modern data architecture
- [02.2 - Data Model Size Reduction](../02%20-%20Performance%20Optimization%20&%20Query%20Design/02.2%20-%20Data%20Model%20Size%20Reduction.md) - Optimizing model size

---

*Last updated: October 2025*
