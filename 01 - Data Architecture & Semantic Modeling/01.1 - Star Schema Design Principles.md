# 01.1 - Star Schema Design Principles

## Overview

Star schema is the foundational data modeling pattern for Power BI semantic models, organizing data into fact tables (business events/transactions) surrounded by dimension tables (descriptive context), forming a "star" shape when visualized. This design pattern, developed by Ralph Kimball for data warehousing, optimizes both query performance and business user comprehension by separating measurable facts from the dimensions used to analyze them. For healthcare analytics at scale, star schema enables the performance, maintainability, and clarity needed to support clinical decision-making workflows.

## Key Principles

- **Simplicity Over Normalization**: Star schema intentionally denormalizes dimensions (flattens hierarchies into single tables) to optimize for query performance and end-user understanding. Unlike OLTP database normalization (3NF), star schema prioritizes analytical query speed.

- **Grain Definition Is Critical**: Each fact table must have a clearly defined grain - the atomic level of detail each row represents (one encounter, one charge, one medication order). Mixed grains in a single fact table cause calculation errors and confusion.

- **Dimension Tables Should Be Wide, Not Tall**: Dimensions should include all descriptive attributes in one table (50+ columns acceptable) rather than splitting into multiple normalized tables. Wide dimensions enable simpler DAX and better query performance.

- **Conformed Dimensions Enable Cross-Subject Analysis**: Dimensions shared across multiple fact tables (DimDate, DimPatient, DimProvider) must have identical structure and keys. This enables analyzing multiple business processes together (encounters + charges + medications for the same patient).

- **Minimize Table Count While Preserving Clarity**: Aim for 5-15 tables in most models (1-3 fact tables, 4-12 dimension tables). More tables create complexity; fewer tables (One Big Table) sacrifice performance and maintainability.

## Practical Example

### Example 1: Healthcare Star Schema Design

**Business Requirements**:

- Analyze patient encounters across providers, facilities, time periods
- Track financial metrics (charges, payments, collections)
- Support clinical quality measures
- Enable provider productivity reporting

**Star Schema Design**:

```
                    DimDate
                       |
                       |
DimPatient -----> FactEncounters <----- DimProvider
                       |
                       |
                 DimFacility
                       |
                       |
                   DimPayer
```

**Fact Table: FactEncounters**

- **Grain**: One row per patient encounter
- **Measures**: ChargeAmount, PaymentAmount, CollectionAmount, EncounterCount (=1), LengthOfStay
- **Foreign Keys**: PatientKey, ProviderKey, FacilityKey, PayerKey, EncounterDate
- **Degenerate Dimensions**: EncounterID, ClaimNumber (transaction identifiers stored in fact)

**Dimension Tables**:

```sql
-- DimPatient (wide dimension with all patient attributes)
CREATE TABLE StarSchema.DimPatient (
    PatientKey INT PRIMARY KEY,           -- Surrogate key
    MRN VARCHAR(20),                      -- Business key
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    DateOfBirth DATE,
    Age INT,                              -- Derived attribute (calculated from DOB)
    AgeGroup VARCHAR(20),                 -- Categorization: "0-17", "18-64", "65+"
    Gender VARCHAR(10),
    Race VARCHAR(50),
    Ethnicity VARCHAR(50),
    Language VARCHAR(50),
    AddressLine1 VARCHAR(200),
    City VARCHAR(100),
    State VARCHAR(2),
    ZipCode VARCHAR(10),
    County VARCHAR(100),
    ServiceArea VARCHAR(50),              -- Derived from zip/county
    PrimaryProviderKey INT,               -- Relationship to DimProvider (patient-provider assignment)
    CarePathway VARCHAR(100),             -- "SMI Care Pathway", "Diabetes Management", etc.
    RiskScore DECIMAL(5,2),
    IsActive BIT,
    EnrollmentDate DATE,
    DisenrollmentDate DATE
    -- 25+ columns is normal for patient dimension
);

-- DimProvider (wide dimension with provider attributes)
CREATE TABLE StarSchema.DimProvider (
    ProviderKey INT PRIMARY KEY,
    NPI VARCHAR(10),                      -- Business key
    ProviderName VARCHAR(200),
    FirstName VARCHAR(100),
    LastName VARCHAR(100),
    Credentials VARCHAR(50),              -- "MD", "NP", "PA", etc.
    Specialty VARCHAR(100),
    SubSpecialty VARCHAR(100),
    PracticeName VARCHAR(200),
    PracticeType VARCHAR(50),             -- "Primary Care", "Specialty", "Urgent Care"
    EmploymentStatus VARCHAR(50),         -- "Employed", "Contracted", "Affiliate"
    HireDate DATE,
    TerminationDate DATE,
    IsActive BIT,
    AcceptingNewPatients BIT,
    PanelSize INT,                        -- Number of attributed patients
    FTE DECIMAL(3,2)                      -- Full-time equivalency
    -- 15-20 columns typical
);

-- DimFacility
CREATE TABLE StarSchema.DimFacility (
    FacilityKey INT PRIMARY KEY,
    FacilityID VARCHAR(20),
    FacilityName VARCHAR(200),
    FacilityType VARCHAR(50),             -- "Hospital", "Clinic", "SNF", "Urgent Care"
    AddressLine1 VARCHAR(200),
    City VARCHAR(100),
    State VARCHAR(2),
    ZipCode VARCHAR(10),
    ServiceArea VARCHAR(50),
    Region VARCHAR(50),
    IsActive BIT
);

-- DimPayer
CREATE TABLE StarSchema.DimPayer (
    PayerKey INT PRIMARY KEY,
    PayerID VARCHAR(20),
    PayerName VARCHAR(200),
    PayerType VARCHAR(50),                -- "Medicare", "Medicaid", "Commercial", "Self-Pay"
    PayerCategory VARCHAR(50),            -- "Government", "Private", "Exchange"
    ContractType VARCHAR(50),             -- "FFS", "Capitated", "Shared Savings"
    IsActive BIT
);

-- DimDate (time dimension - see Topic 03.4)
CREATE TABLE StarSchema.DimDate (
    DateKey INT PRIMARY KEY,              -- YYYYMMDD format: 20251021
    Date DATE,
    Year INT,
    Quarter INT,
    Month INT,
    MonthName VARCHAR(20),
    Week INT,
    DayOfWeek INT,
    DayName VARCHAR(20),
    FiscalYear INT,
    FiscalQuarter INT,
    IsWeekend BIT,
    IsHoliday BIT,
    HolidayName VARCHAR(100)
);
```

**Why This Works**:

- **Clear grain**: One encounter per row in FactEncounters
- **Wide dimensions**: All patient attributes in DimPatient (no separate DimAddress, DimDemographics tables)
- **Conformed dimensions**: DimDate, DimPatient, DimProvider shared across other fact tables (FactCharges, FactMedications)
- **Simple relationships**: Each fact has 1:Many relationship to each dimension
- **Optimal table count**: 5 dimensions + 1 fact = 6 tables (simple, maintainable)

### Example 2: Conformed Dimensions Across Multiple Facts

**Scenario**: Add financial fact table for charge detail (multiple charges per encounter).

**Star Schema Extension**:

```
                      DimDate
                     /      \
                    /        \
DimPatient --> FactEncounters  FactCharges <-- DimService
                    \        /
                     \      /
                   DimProvider
```

**New Fact Table**:

```sql
CREATE TABLE StarSchema.FactCharges (
    ChargeKey INT PRIMARY KEY,
    EncounterKey INT,                     -- FK to FactEncounters (charge belongs to encounter)
    PatientKey INT,                       -- FK to DimPatient (conformed dimension)
    ProviderKey INT,                      -- FK to DimProvider (conformed dimension)
    ServiceKey INT,                       -- FK to DimService
    ChargeDate DATE,                      -- FK to DimDate (conformed dimension)
    ServiceDate DATE,

    -- Measures
    ChargeAmount DECIMAL(10,2),
    AllowedAmount DECIMAL(10,2),
    PaidAmount DECIMAL(10,2),
    AdjustmentAmount DECIMAL(10,2),
    ChargeCount INT                       -- Always 1 for row count
);
```

**Conformed Dimension Benefits**:

- DimPatient shared between FactEncounters and FactCharges
- Can analyze "Total encounters AND total charges by patient" using same dimension
- Slicer on DimPatient filters both fact tables consistently
- No need to create separate patient dimensions for each fact

**Example Analysis Enabled**:

```dax
// Measure using both facts with conformed DimPatient
Revenue Per Encounter =
DIVIDE(
    SUM(FactCharges[PaidAmount]),      // From FactCharges
    SUM(FactEncounters[EncounterCount]) // From FactEncounters
)
// Works because both facts link to same DimPatient dimension
```

### Example 3: Defining Proper Grain

**L Wrong: Mixed Grain in Single Fact Table**

```sql
-- BAD: Mixing encounter-level and charge-level grains
CREATE TABLE FactEncounterCharges (
    RowID INT,
    EncounterID VARCHAR(20),
    PatientKey INT,
    EncounterDate DATE,
    ChargeDate DATE,                  -- Wait, one or many charges per encounter?
    ServiceCode VARCHAR(20),          -- Which service? One or many?
    ChargeAmount DECIMAL(10,2),       -- One encounter can have 5 charges!
    LengthOfStay INT                  -- Encounter-level, but duplicated across charges
);

-- Results in:
-- Row 1: Encounter 12345, Charge 1 for $150, LOS = 2
-- Row 2: Encounter 12345, Charge 2 for $200, LOS = 2  (LOS duplicated!)
-- Row 3: Encounter 12345, Charge 3 for $75,  LOS = 2  (LOS duplicated!)
-- SUM(LengthOfStay) = 6 days, but should be 2 days!
```

** Correct: Separate Facts with Clear Grains**

```sql
-- FactEncounters: Grain = One Encounter
CREATE TABLE FactEncounters (
    EncounterKey INT PRIMARY KEY,
    EncounterID VARCHAR(20),
    PatientKey INT,
    EncounterDate DATE,
    LengthOfStay INT,                 -- Correct: one value per encounter
    EncounterCount INT                -- Always 1
);

-- FactCharges: Grain = One Charge Line
CREATE TABLE FactCharges (
    ChargeKey INT PRIMARY KEY,
    EncounterKey INT,                 -- Links to FactEncounters
    ServiceKey INT,
    ChargeDate DATE,
    ChargeAmount DECIMAL(10,2),       -- Correct: one value per charge
    ChargeCount INT                   -- Always 1
);
```

**Why This Works**:

- Clear, atomic grain for each fact
- No duplication or aggregation errors
- Can analyze at either grain: encounters or charges
- Correct totals: SUM(FactEncounters[LengthOfStay]) = total patient days

## Common Pitfalls

### L Pitfall 1: Snowflaking Dimensions (Over-Normalization)

**Description**: Breaking dimensions into multiple normalized tables (e.g., separating DimProvider, DimPractice, DimSpecialty into 3 related tables).

**Impact**:

- Multiple table joins required for simple queries (DimProvider � DimPractice � DimSpecialty)
- Slower query performance (more joins = more work for formula engine)
- Complex DAX (need RELATED across multiple hops)
- Harder for business users to understand model

**Example of Snowflaking (Avoid)**:

```
DimProvider ----> DimPractice ----> DimRegion
```

**Fix**: Denormalize into single wide dimension:

```sql
CREATE TABLE DimProvider (
    ProviderKey INT PRIMARY KEY,
    ProviderName VARCHAR(200),
    Specialty VARCHAR(100),
    PracticeName VARCHAR(200),        -- Denormalized from DimPractice
    PracticeType VARCHAR(50),         -- Denormalized from DimPractice
    Region VARCHAR(50),               -- Denormalized from DimRegion
    ServiceArea VARCHAR(50)           -- Denormalized from DimRegion
);
```

Star schema accepts this "redundancy" (PracticeName repeated for all providers in same practice) because:

- Dimension tables are small (thousands of providers vs millions of encounters)
- VertiPaq compression handles redundancy well
- Query performance dramatically better
- Simpler for users and developers

### L Pitfall 2: Creating Too Many Fact Tables

**Description**: Creating separate fact tables for every minor variation (FactInpatientEncounters, FactOutpatientEncounters, FactUrgentCareEncounters, etc.).

**Impact**:

- Model complexity (15+ tables)
- Duplicate dimension tables or complex relationships
- Hard to get "total encounters across all types"
- Maintenance burden (same changes in multiple places)

**Fix**: Use a single fact with encounter type dimension or attribute:

```sql
-- Single fact with encounter type
CREATE TABLE FactEncounters (
    EncounterKey INT PRIMARY KEY,
    EncounterTypeKey INT,             -- FK to DimEncounterType dimension
    -- OR --
    EncounterType VARCHAR(50),        -- Degenerate dimension: "Inpatient", "Outpatient", "Urgent Care"
    PatientKey INT,
    EncounterDate DATE,
    ChargeAmount DECIMAL(10,2)
);

-- Simple DAX filters by type
Inpatient Encounters =
CALCULATE(
    [Total Encounters],
    FactEncounters[EncounterType] = "Inpatient"
)
```

**When Multiple Facts ARE Appropriate**:

- Different grains (FactEncounters vs FactCharges)
- Completely different business processes (FactEncounters vs FactMedications vs FactLabResults)
- Different dimensions involved (different foreign keys)

### L Pitfall 3: Bidirectional or Many-to-Many Relationships

**Description**: Creating bidirectional filters or many-to-many relationships to "make slicers work both ways."

**Impact**:

- Unpredictable filter behavior (filters propagate in unexpected directions)
- Ambiguous filter paths (which direction should filter flow?)
- Performance degradation (engine must evaluate multiple filter paths)
- Hard to troubleshoot DAX behavior

**Fix**: Keep relationships unidirectional (dimension � fact):

```
DimPatient (1) -----> (*) FactEncounters    Correct
               (one-way filter: dimension filters fact)

DimPatient (1) <----> (*) FactEncounters    Avoid
               (bidirectional filters cause ambiguity)
```

For many-to-many scenarios (patient has multiple providers, provider has multiple patients), use:

1. Bridge table between dimensions
2. DAX measures with CROSSFILTER or TREATAS
3. Security table for RLS scenarios

See [01.3 - Relationship Configuration & Cardinality](01.3%20-%20Relationship%20Configuration%20&%20Cardinality.md) for detailed guidance.

## Healthcare Context

### Performance Considerations

Star schema design directly enables <5 second load time SLA:

**VertiPaq Optimization**: Star schema aligns perfectly with Power BI's columnar storage engine:

- Fact tables have many rows (millions), few columns (optimized for columnar compression)
- Dimension tables have few rows (thousands), many columns (minimal impact on model size)
- Integer foreign keys compress to 1-2 bytes per value
- Text attributes in dimensions compressed once (not duplicated in facts)

**Query Engine Efficiency**: Simple star relationships enable formula engine optimization:

- One-hop joins (fact � dimension, no multi-hop navigation)
- Predictable filter propagation (dimensions filter facts)
- Storage engine can pushdown more operations

**AbsoluteCare Results**: Moving from "One Big Table" to star schema:

- 40-60% model size reduction
- 75-90% query performance improvement
- Refresh time reduced by 50%

### Print/Mobile Implications

**Smaller Models**: Star schema compression benefits mobile app downloads and offline scenarios. A 500MB star schema model might be 1.2GB as a denormalized table - affecting mobile data usage and storage.

**Consistent Dimensions**: Conformed dimensions mean consistent slicer behavior across all reports in a mobile app workspace. User learns patient slicer behavior once, applies to all reports.

### Compliance Notes

**Data Lineage**: Star schema makes data lineage obvious:

- Fact: Where business events come from (EncounterSource system)
- Each dimension: Clear source of truth (DimPatient from Member Master)
- Supports HIPAA audit requirements for data provenance

**Security Implementation**: Star schema simplifies row-level security:

- Apply RLS filters to dimension tables (DimPatient, DimProvider)
- Filter propagates to facts automatically via relationships
- Easier to audit and validate than securing denormalized tables

See [06.1 - Row-Level Security Patterns](../06%20-%20Governance%20Security%20&%20Deployment/06.1%20-%20Row-Level%20Security%20Patterns.md) for RLS implementation.

## Learn More

### Official Documentation

- [Star Schema Design in Power BI](https://learn.microsoft.com/en-us/power-bi/guidance/star-schema) - Microsoft best practices for star schema modeling
- [Model Relationships in Power BI](https://learn.microsoft.com/en-us/power-bi/transform-model/desktop-relationships-understand) - Understanding relationship behavior

### Expert Resources

- [The Data Warehouse Toolkit (3rd Edition)](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/books/data-warehouse-dw-toolkit/) - Ralph Kimball's definitive guide to dimensional modeling
- [Analyzing Data with Power BI and Power Pivot for Excel](https://www.sqlbi.com/books/analyzing-data-with-microsoft-power-bi-and-power-pivot-for-excel/) - Marco Russo & Alberto Ferrari, Chapters 5-8 on data modeling



### Video Content

- [Star Schema Fundamentals](https://www.youtube.com/c/GuyinaCube) - Guy in a Cube explanation of star schema concepts
- [Dimensional Modeling Best Practices](https://www.youtube.com/c/SQLBI) - SQLBI video on Kimball methodology in Power BI

### Related Topics

- [01.2 - Fact vs Dimension Tables](01.2%20-%20Fact%20vs%20Dimension%20Tables.md) - Detailed fact and dimension characteristics
- [01.3 - Relationship Configuration & Cardinality](01.3%20-%20Relationship%20Configuration%20&%20Cardinality.md) - Creating and managing relationships
- [01.5 - Bridging to Medallion Architecture](01.5%20-%20Bridging%20to%20Medallion%20Architecture.md) - Star schema in modern data architectures
- [02.2 - Data Model Size Reduction](../02%20-%20Performance%20Optimization%20&%20Query%20Design/02.2%20-%20Data%20Model%20Size%20Reduction.md) - Optimizing star schema for size
- [06.1 - Row-Level Security Patterns](../06%20-%20Governance%20Security%20&%20Deployment/06.1%20-%20Row-Level%20Security%20Patterns.md) - Security in star schema

---

*Last updated: October 2025*