# 02.1 - Query Folding & Import vs DirectQuery

## Overview

One of the most impactful decisions in Power BI data architecture is choosing between Import mode and DirectQuery mode for data connectivity. Import mode loads data into Power BI's in-memory engine for fast query performance but requires scheduled refreshes. DirectQuery mode queries the source database in real-time, providing live data but depending on source database performance. This topic explains how each mode works, when to use each, and how query folding in Power Query impacts performance in both modes - with specific guidance from AbsoluteCare's successful migration to Import mode.

## Key Principles

- **Import Mode is Default for Best Performance**: Import mode leverages Power BI's highly optimized in-memory engine (VertiPaq), delivering sub-second query performance even on complex DAX calculations. For healthcare analytics where <5 second load times are critical, Import mode typically provides the best user experience.

- **DirectQuery Provides Real-Time Data at a Cost**: DirectQuery sends queries directly to the source database for every visual refresh, providing real-time data but introducing network latency and dependency on source database performance. Use DirectQuery only when real-time data is genuinely required and source performance is excellent.

- **Query Folding Determines Power Query Performance**: Query folding is Power Query's ability to translate M code transformations into native SQL queries pushed back to the source database. When query folding works, data transformations happen efficiently at the database. When it breaks, Power BI pulls raw data and processes it locally - dramatically impacting performance.

- **Hybrid Approaches Exist for Special Cases**: Composite models allow combining Import and DirectQuery tables in the same semantic model, aggregations enable caching frequently-used summaries while maintaining DirectQuery connections, and incremental refresh provides Import performance with near-real-time updates.

- **Test Connection Mode Changes with Production Data Volumes**: A report that performs acceptably in DirectQuery with 10,000 rows may time out with 1 million rows. Always test with representative data volumes before deploying connection mode decisions.

## Practical Example

### Example 1: AbsoluteCare's Migration from DirectQuery to Import

**Initial State**: Multiple Power BI reports using DirectQuery connections to SQL Server data warehouse (ABCDW), experiencing:
- Report load times exceeding 8-12 seconds (above 5-second SLA)
- User complaints about slow performance
- Providers abandoning reports during clinical workflows

**Analysis**: Performance Analyzer revealed most time spent in "DAX query" execution (4-8 seconds per visual), indicating data engine bottleneck rather than visual rendering issues.

**Solution**: Migrated all reports to Import mode with scheduled refresh.

**Implementation Steps**:

1. **Verify Data Refresh Requirements**
   - Determined daily refresh at 6:00 AM met business needs (data updated overnight)
   - Confirmed real-time data not required for daily huddles or provider dashboards
   - Identified no use cases requiring intra-day data updates

2. **Check Data Volume**
   - Assessed table sizes in source database
   - Confirmed largest fact table (~5M rows) would fit in Import mode
   - Estimated total semantic model size ~500 MB (well under 1 GB Free/Pro limit, 10 GB Premium limit)

3. **Switch to Import Mode**
   ```powerquery
   // In Power Query Editor, for each data source:
   // 1. Right-click table in Queries pane
   // 2. Select "Properties"
   // 3. Under "Connection", change from "DirectQuery" to "Import"
   // 4. Click "OK"
   ```

4. **Optimize Power Query for Import**
   ```powerquery
   // Remove unnecessary columns early in transformation
   let
       Source = Sql.Database("ABCDW-Server", "Healthcare"),
       FactEncounters = Source{[Schema="dbo",Item="FactEncounters"]}[Data],

       // Remove columns not needed for reporting (reduce import size)
       RemoveColumns = Table.RemoveColumns(FactEncounters, {
           "InternalSystemID", "LegacySourceKey", "AuditTimestamp"
       }),

       // Filter to relevant date range (reduce import size)
       FilterDates = Table.SelectRows(RemoveColumns,
           each [EncounterDate] >= #date(2023,1,1)
       ),

       // Set data types explicitly (optimize VertiPaq compression)
       SetTypes = Table.TransformColumnTypes(FilterDates, {
           {"EncounterID", Int64.Type},
           {"PatientKey", Int64.Type},
           {"ProviderKey", Int64.Type},
           {"EncounterDate", type date},
           {"ChargeAmount", Currency.Type}
       })
   in
       SetTypes
   ```

5. **Set Up Scheduled Refresh**
   - In Power BI Service workspace, configure data source credentials
   - Set refresh schedule: Daily at 6:00 AM (before staff arrive)
   - Enable refresh failure notifications to report owners
   - Test initial refresh to ensure no errors

**Results**:
- Report load times dropped from 8-12 seconds to <2 seconds (75-90% improvement)
- User satisfaction increased dramatically
- Report abandonment during clinical workflows eliminated
- Minimal impact to operations (overnight refresh met all business needs)

**Why this works**: Import mode loads data into Power BI's in-memory VertiPaq engine, which uses aggressive compression and columnar storage optimized for analytical queries. DAX calculations execute against in-memory data structures orders of magnitude faster than querying a remote database.

### Example 2: Understanding Query Folding in Power Query

**Scenario**: Loading a patient dimension from SQL Server with transformations in Power Query.

**Query Folding Success (Efficient)**:

```powerquery
let
    Source = Sql.Database("ABCDW-Server", "Healthcare"),
    DimPatient = Source{[Schema="dbo",Item="DimPatient"]}[Data],

    //  Query folding: Filter translates to SQL WHERE clause
    FilterActive = Table.SelectRows(DimPatient,
        each [IsActive] = true
    ),

    //  Query folding: Remove columns translates to SQL SELECT specific columns
    SelectColumns = Table.SelectColumns(FilterActive, {
        "PatientKey", "MRN", "FirstName", "LastName", "DateOfBirth"
    }),

    //  Query folding: Rename columns translates to SQL aliases
    RenameColumns = Table.RenameColumns(SelectColumns, {
        {"MRN", "MedicalRecordNumber"}
    })
in
    RenameColumns
```

**Resulting SQL** (visible in Query Dependencies view ’ Right-click step ’ View Native Query):

```sql
SELECT
    PatientKey,
    MRN AS MedicalRecordNumber,
    FirstName,
    LastName,
    DateOfBirth
FROM dbo.DimPatient
WHERE IsActive = 1
```

**Why this works**: Power Query translated all M code transformations into a single SQL query pushed to the database. The database performs filtering and column selection, sending only the needed data to Power BI.

**Query Folding Failure (Inefficient)**:

```powerquery
let
    Source = Sql.Database("ABCDW-Server", "Healthcare"),
    DimPatient = Source{[Schema="dbo",Item="DimPatient"]}[Data],

    FilterActive = Table.SelectRows(DimPatient,
        each [IsActive] = true
    ),

    //  Query folding breaks: Text.Proper() is M function, not SQL function
    ProperCase = Table.TransformColumns(FilterActive, {
        {"FirstName", Text.Proper},
        {"LastName", Text.Proper}
    }),

    //  All subsequent steps cannot fold
    SelectColumns = Table.SelectColumns(ProperCase, {
        "PatientKey", "MRN", "FirstName", "LastName"
    })
in
    SelectColumns
```

**Impact**: Power Query pulls ALL rows from `DimPatient` to Power BI, applies `Text.Proper()` locally, then selects columns. Instead of sending only needed data, the database sends the entire table to Power BI for client-side processing.

**Fix Options**:

1. **Perform transformation in database** (best):
   ```sql
   -- Create a view in SQL Server with proper casing
   CREATE VIEW dbo.vwDimPatient AS
   SELECT
       PatientKey,
       MRN,
       UPPER(LEFT(FirstName,1)) + LOWER(SUBSTRING(FirstName,2,100)) AS FirstName,
       UPPER(LEFT(LastName,1)) + LOWER(SUBSTRING(LastName,2,100)) AS LastName,
       DateOfBirth,
       IsActive
   FROM dbo.DimPatient;
   ```

   ```powerquery
   // Reference the view instead
   Source = Sql.Database("ABCDW-Server", "Healthcare"),
   DimPatient = Source{[Schema="dbo",Item="vwDimPatient"]}[Data],
   FilterActive = Table.SelectRows(DimPatient, each [IsActive] = true)
   ```

2. **Accept the query folding break if data volume is small** (acceptable for small dimensions):
   - If `DimPatient` has only 5,000 rows, the performance impact is minimal
   - Query folding is critical for large fact tables (millions of rows)
   - Less critical for small dimension tables (thousands of rows)

3. **Use Native SQL Query** (alternative):
   ```powerquery
   let
       Source = Sql.Database("ABCDW-Server", "Healthcare"),
       NativeQuery = Value.NativeQuery(Source, "
           SELECT
               PatientKey,
               MRN,
               UPPER(LEFT(FirstName,1)) + LOWER(SUBSTRING(FirstName,2,100)) AS FirstName,
               UPPER(LEFT(LastName,1)) + LOWER(SUBSTRING(LastName,2,100)) AS LastName
           FROM dbo.DimPatient
           WHERE IsActive = 1
       ")
   in
       NativeQuery
   ```

**How to Check Query Folding**:
1. In Power Query Editor, right-click a transformation step
2. If "View Native Query" option is available and not grayed out, query folding worked
3. If "View Native Query" is grayed out, query folding broke at or before this step

## Common Pitfalls

### L Pitfall 1: Using DirectQuery Without Testing Database Performance

**Description**: Choosing DirectQuery because "real-time data" sounds beneficial without verifying the source database can handle concurrent Power BI query load with acceptable performance.

**Impact**: Every visual refresh sends queries to the source database. A dashboard with 10 visuals sends 10+ queries. With 20 concurrent users, that's 200+ simultaneous database queries, overwhelming database resources and causing timeouts or slowdowns for all users (including operational systems sharing the database).

**Fix**:
- **Test realistic concurrency**: Open the report from 5-10 browser sessions simultaneously
- **Monitor source database during tests**: Check query execution times, CPU, memory
- **Use Database Query Governor** in Power BI Service to set maximum query time limits
- **Consider Import mode with scheduled refresh** if near-real-time is acceptable (refresh every 15-30 minutes meets most healthcare needs)

### L Pitfall 2: Breaking Query Folding with Unnecessary M Functions

**Description**: Using Power Query M functions that don't translate to SQL (Text.Proper, List.Generate, custom functions) when equivalent database transformations are available.

**Impact**: Query folding breaks, forcing Power BI to pull entire tables across the network for client-side processing. A fact table with 5 million rows that should transfer as 50 MB (compressed) instead transfers as 500 MB (uncompressed raw data), causing:
- 10x longer refresh times
- Network bandwidth saturation
- Potential refresh timeouts and failures

**Fix**:
- Perform complex transformations in SQL Server views instead of Power Query
- Check query folding status frequently during Power Query development
- Prioritize foldable transformations (filters, column selection, simple calculations)
- For large tables (>100K rows), ensure query folding works for all steps

### L Pitfall 3: Assuming DirectQuery = Real-Time

**Description**: Choosing DirectQuery thinking it provides "real-time" data, without understanding Power BI caches DirectQuery results for 1 hour by default.

**Impact**: Users see DirectQuery dashboard and assume data is live, but see stale data from cache. This causes confusion ("Why is the census count wrong?") and missed SLA expectations. True real-time behavior requires disabling caching, which dramatically increases database load and decreases performance.

**Fix**:
- Understand DirectQuery cache settings:
  - Default: 1-hour cache in Power BI Service
  - Can be reduced to minimum 15 minutes
  - Can be disabled entirely (not recommended - massive performance impact)
- Communicate actual data freshness to users ("Data refreshed hourly")
- Consider Import with frequent refresh (every 30-60 minutes) for similar freshness with better performance

## Healthcare Context

### Performance Considerations

Connection mode directly impacts the <5 second clinical workflow SLA:

**Import Mode Advantages for Healthcare**:
- **Predictable Performance**: Query execution time doesn't depend on database load, network latency, or concurrent users
- **Sub-Second Response**: Even complex DAX calculations complete in 100-500ms in Import mode
- **Works Offline**: Mobile users can view reports cached on devices without network connectivity
- **Reduced IT Infrastructure Load**: Database only handles overnight refreshes, not continuous query traffic

**AbsoluteCare Success**: Migrating to Import mode was the single highest-impact performance optimization, reducing report load times by 75-90% and eliminating clinical workflow disruptions.

**When DirectQuery Might Be Considered**:
- Truly real-time operational dashboards (bed management, ED census)
- Data volumes exceeding Power BI capacity limits (>10 GB in Premium)
- Regulatory requirements prohibiting data duplication
- Source database performance excellent and dedicated for BI workloads

Even in these cases, consider composite models with Import for dimensions and DirectQuery only for real-time fact tables.

### Print/Mobile Implications

**Import Mode Benefits**:
- Printed reports reflect data as of last refresh (documented refresh time in footer)
- Mobile users can view cached reports without connectivity (Power BI mobile app)
- Offline scenarios supported (providers in rural areas, facilities with poor connectivity)

**DirectQuery Limitations**:
- Mobile users require constant network connectivity
- Poor network performance causes report failures on mobile devices
- Print subscriptions may fail if database unavailable during scheduled email delivery

### Compliance Notes

**Data Residency**: Import mode copies PHI from source database to Power BI Service. Ensure:
- Power BI Service tenant region matches healthcare data residency requirements
- Row-level security implemented to restrict user access to appropriate patients
- Data refresh credentials use service accounts with minimal permissions (read-only access to needed tables)

**Audit Trail**: Import mode refresh history available in Power BI Service. DirectQuery sends queries with service account credentials, making user-level audit trails more complex. See [06.1 - Row-Level Security Patterns](../06%20-%20Governance%20Security%20&%20Deployment/06.1%20-%20Row-Level%20Security%20Patterns.md) for security implementation.

## Learn More

### Official Documentation
- [Import vs DirectQuery vs Live Connection](https://learn.microsoft.com/en-us/power-bi/connect-data/desktop-directquery-about) - Microsoft comprehensive guide to connection modes
- [Query Folding in Power Query](https://learn.microsoft.com/en-us/power-query/power-query-folding) - Official documentation on query folding mechanics

### Expert Resources
- [DirectQuery Best Practices](https://www.sqlbi.com/articles/directquery-best-practices/) - SQLBI guidance from Marco Russo and Alberto Ferrari
- [Import Mode Optimization](https://www.sqlbi.com/articles/optimizing-import-mode/) - Techniques for maximizing Import mode performance
- [Query Folding Deep Dive](https://www.powerquery.how/query-folding/) - Detailed explanation with examples

### Video Content
- [Import vs DirectQuery: When to Use Each](https://www.youtube.com/c/GuyinaCube) - Guy in a Cube decision framework
- [Query Folding Explained](https://www.youtube.com/c/GuyinaCube) - Visual demonstration of query folding concepts

### Related Topics
- [02.2 - Data Model Size Reduction](02.2%20-%20Data%20Model%20Size%20Reduction.md) - Optimizing Import mode semantic model size
- [02.3 - Incremental Refresh Strategies](02.3%20-%20Incremental%20Refresh%20Strategies.md) - Import performance with near-real-time updates
- [01.2 - Fact vs Dimension Tables](../01%20-%20Data%20Architecture%20&%20Semantic%20Modeling/01.2%20-%20Fact%20vs%20Dimension%20Tables.md) - Data model design impacts connection mode performance
- [02.4 - Performance Analyzer Workflow](02.4%20-%20Performance%20Analyzer%20Workflow.md) - Measuring connection mode performance impact

---

*Last updated: October 2025*
